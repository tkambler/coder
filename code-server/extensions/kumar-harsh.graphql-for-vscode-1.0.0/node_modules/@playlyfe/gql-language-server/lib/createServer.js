"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createServer;

var _log4js = require("log4js");

var _gql = require("./utils/gql");

var _Disposable = require("./utils/Disposable");

var _Completion = _interopRequireDefault(require("./providers/Completion"));

var _Definition = _interopRequireDefault(require("./providers/Definition"));

var _References = _interopRequireDefault(require("./providers/References"));

var _Diagnostics = _interopRequireDefault(require("./providers/Diagnostics"));

var _Hover = _interopRequireDefault(require("./providers/Hover"));

var _vscodeLanguageserver = require("vscode-languageserver");

const logger = (0, _log4js.getLogger)('gql-language-server');
const gqlLogger = (0, _log4js.getLogger)(); // logger name will be set while logging

function createServer(connection, options) {
  logger.info(`running in node ${process.version} (${process.execPath})`);
  const disposable = new _Disposable.CompositeDisposable();
  const documents = new _vscodeLanguageserver.TextDocuments(_vscodeLanguageserver.TextDocumentSyncKind.Incremental);
  logger.debug('creating server with options', options);
  connection.onShutdown(() => {
    logger.info('server connection shutting down');
    disposable.dispose();
  });
  connection.onInitialize(async params => {
    logger.debug('onInitiialized called');
    const gqlService = await (0, _gql.loadGQLService)({
      configDir: options.configDir || params.rootPath || process.cwd(),
      gqlPath: options.gqlPath || params.rootPath || process.cwd(),
      watchman: options.watchman,
      autoDownloadGQL: options.autoDownloadGQL,
      debug: options.loglevel === 'debug'
    });
    const onErrorSubscription = gqlService.onError(err => logger.error(err));
    const onLogSubscription = gqlService.onLog(({
      level,
      name,
      args
    }) => {
      gqlLogger.category = name;
      gqlLogger[level](...args);
    }); // cleanup gqlService

    disposable.add(new _Disposable.Disposable(() => {
      gqlService.stop();
      onErrorSubscription.remove();
      onLogSubscription.remove();
    }));

    try {
      logger.info('starting gql service...');
      await gqlService.start();
      logger.info('gql service started');
    } catch (err) {
      if (logger.isDebugEnabled()) {
        logger.error(err);
      }

      throw err;
    } // setup providers


    setupProviders(connection, gqlService, documents);
    logger.info('gql-language-server started'); // check client

    if (checkClientSupportsDynamicRegistrations(params.capabilities)) {
      logger.debug('Client supports dynamic registrations. Capabilities will be registered dynamically');
      connection.onInitialized(() => {
        registerCapabilitiesDynamically({
          gqlService,
          connection,
          syncKind: documents.syncKind,
          clientSupportsRelativePattern: typeof params.initializationOptions === 'object' && params.initializationOptions !== null ? params.initializationOptions.relativePattern === true : false
        });
      });
      return {
        capabilities: {},
        fileExtensions: gqlService.getConfig().getFileExtensions()
      };
    } // if dynamic registrations not supported


    logger.debug('Client does not support dynamic registrations.');
    return {
      capabilities: {
        textDocumentSync: documents.syncKind,
        definitionProvider: true,
        hoverProvider: true,
        referencesProvider: true,
        completionProvider: Object.freeze({
          resolveProvider: false,
          triggerCharacters: ['.']
        })
      },
      fileExtensions: gqlService.getConfig().getFileExtensions()
    };
  });
  return {
    listen() {
      documents.listen(connection);
      connection.listen();
    }

  };
}

function setupProviders(connection, gqlService, documents) {
  // diagnostics
  const diagnostics = new _Diagnostics.default({
    gqlService
  });
  diagnostics.listen(diagnosticItems => {
    diagnosticItems.forEach(connection.sendDiagnostics);
  }); // completion

  const completion = new _Completion.default({
    documents,
    gqlService
  });
  connection.onCompletion(docParams => {
    logger.debug(`completion requested for document ${docParams.textDocument.uri}`);
    return completion.provideCompletionItems(docParams);
  }); // definition

  const definition = new _Definition.default({
    documents,
    gqlService
  });
  connection.onDefinition(docParams => {
    logger.debug(`definition requested for document ${docParams.textDocument.uri}`);
    return definition.provideDefinition(docParams);
  }); // find refs

  const references = new _References.default({
    documents,
    gqlService
  });
  connection.onReferences(docParams => {
    logger.debug(`references requested for document ${docParams.textDocument.uri}`);
    return references.provideReferences(docParams);
  }); // hover

  const hover = new _Hover.default({
    documents,
    gqlService
  });
  connection.onHover(docParams => {
    logger.debug(`hover requested for document ${docParams.textDocument.uri}`);
    return hover.provideHover(docParams);
  });
}

function registerCapabilitiesDynamically(params) {
  const gqlConfig = params.gqlService.getConfig();
  const extensions = gqlConfig.getFileExtensions();
  const pattern = `**/*.{${extensions.join(',')}}`;
  const documentOptions = {
    documentSelector: [{
      scheme: 'file',
      // NOTE: relative pattern is not mentioned in lsp spec
      // but vscode supports it so enabling under a flag
      pattern: params.clientSupportsRelativePattern ? {
        base: gqlConfig.getDir(),
        pattern
      } : pattern
    }]
  };
  logger.info('Dynamically registering capabilities for documents matching', JSON.stringify(documentOptions.documentSelector, null, 2));

  const registration = _vscodeLanguageserver.BulkRegistration.create();

  registration.add(_vscodeLanguageserver.DidOpenTextDocumentNotification.type, documentOptions);
  registration.add(_vscodeLanguageserver.DidChangeTextDocumentNotification.type, {
    documentSelector: documentOptions.documentSelector,
    syncKind: params.syncKind
  });
  registration.add(_vscodeLanguageserver.DidCloseTextDocumentNotification.type, documentOptions);
  registration.add(_vscodeLanguageserver.CompletionRequest.type, documentOptions);
  registration.add(_vscodeLanguageserver.HoverRequest.type, documentOptions);
  registration.add(_vscodeLanguageserver.DefinitionRequest.type, documentOptions);
  registration.add(_vscodeLanguageserver.ReferencesRequest.type, documentOptions);
  params.connection.client.register(registration);
}

function checkClientSupportsDynamicRegistrations(capabilities) {
  // FIXME: Improve this
  // checking dynamicRegistration for only one capability and assuming others
  // also supports dynamicRegistrations
  return capabilities && capabilities.textDocument && capabilities.textDocument.completion && capabilities.textDocument.completion.dynamicRegistration;
}