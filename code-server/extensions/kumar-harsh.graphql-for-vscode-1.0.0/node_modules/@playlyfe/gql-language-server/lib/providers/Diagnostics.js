"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeLSPDiagnostic = makeLSPDiagnostic;
exports.default = void 0;

var _Emitter = _interopRequireDefault(require("../utils/Emitter"));

var _helpers = require("../utils/helpers");

class Diagnostics {
  // stores latest diagnostic items
  constructor({
    gqlService
  }) {
    this.gqlService = void 0;
    this._emitter = new _Emitter.default();
    this.diagnostics = [];

    this._updateDiagnostics = () => {
      const errors = this.gqlService.status();
      const SCHEMA_FILE = '__schema__';
      const diagnosticsMap = {};
      const diagnostics = [];
      errors.forEach(error => {
        const {
          locations
        } = error;

        if (!locations) {
          // global error will be grouped under __schema__
          if (!diagnosticsMap[SCHEMA_FILE]) {
            diagnosticsMap[SCHEMA_FILE] = {
              uri: SCHEMA_FILE,
              diagnostics: []
            };
          }

          diagnosticsMap[SCHEMA_FILE].diagnostics.push(makeLSPDiagnostic(error, {
            line: 1,
            column: 1
          }));
        } else {
          locations.forEach(loc => {
            if (!diagnosticsMap[loc.path]) {
              diagnosticsMap[loc.path] = {
                uri: (0, _helpers.filePathToURI)(loc.path),
                diagnostics: []
              };
            }

            diagnosticsMap[loc.path].diagnostics.push(makeLSPDiagnostic(error, loc));
          });
        }
      }); // report new errors

      const diagnosticItems = [];
      Object.keys(diagnosticsMap).forEach(file => {
        diagnostics.push({
          file,
          params: diagnosticsMap[file]
        });
        diagnosticItems.push(diagnosticsMap[file]);
      }); // clear old errors

      const clearDiagnosticItems = [];
      this.diagnostics.forEach(({
        file,
        params
      }) => {
        if (diagnosticsMap[file]) {
          return;
        }

        clearDiagnosticItems.push({
          uri: params.uri,
          diagnostics: []
        });
      });
      this.diagnostics = diagnostics;

      this._emitter.emit('update', [...diagnosticItems, ...clearDiagnosticItems]);
    };

    this.gqlService = gqlService;
    this.gqlService.onChange(this._updateDiagnostics);
    process.nextTick(() => this._updateDiagnostics());
  }

  listen(listener) {
    return this._emitter.on('update', listener);
  }

}

exports.default = Diagnostics;

function makeLSPDiagnostic(error, position) {
  const startPosition = (0, _helpers.gqlPositionToLSPPosition)(position);
  return {
    range: {
      start: startPosition,
      end: startPosition
    },
    message: error.message,
    severity: (0, _helpers.gqlErrorSeverityToDiagnosticSeverity)(error.severity),
    code: 'syntax',
    source: 'graphql'
  };
}