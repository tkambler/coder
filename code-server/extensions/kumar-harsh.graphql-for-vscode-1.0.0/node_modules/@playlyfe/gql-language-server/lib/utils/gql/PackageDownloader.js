"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _child_process = require("child_process");

var _os = _interopRequireDefault(require("os"));

var _types = require("./types");

const YARN_CLI_PATH = require.resolve('yarn/bin/yarn.js');

class PackageDownloader {
  constructor({
    logger
  }) {
    this.dir = '';
    this.logger = void 0;
    this.logger = logger;
    this.dir = this._getDownloadsDirPath();
  }

  async getPackage({
    version,
    name
  }) {
    if (!(await this._verifyPackage({
      version,
      name
    }))) {
      await this._downloadPackage({
        version,
        name
      });
    }

    return this._genPathForPackage({
      version,
      name
    });
  }

  async clean() {
    await _fsExtra.default.emptyDir();
  }

  async _downloadPackage({
    version,
    name
  }) {
    const pkgPath = this._genPathForPackage({
      version,
      name
    });

    const pkgName = `${name}@${version}`; // make sure directory is empty

    await _fsExtra.default.emptyDir(pkgPath);
    this.logger.info(`[yarn] downloading ${pkgName} in ${pkgPath}...`);
    (0, _child_process.execSync)(`node ${YARN_CLI_PATH} add ${pkgName}`, {
      cwd: pkgPath,
      encoding: 'utf8'
    });
    this.logger.info(`[yarn] ${pkgName} downloaded.`);
  }

  async _verifyPackage({
    name,
    version
  }) {
    const pkgPath = this._genPathForPackage({
      version,
      name
    }); // check package present


    const found = await this._isPackagePresent({
      name,
      version
    });

    if (!found) {
      return false;
    } // check install package not modified


    try {
      (0, _child_process.execSync)(`node ${YARN_CLI_PATH} check`, {
        cwd: pkgPath,
        encoding: 'utf8',
        stdio: 'ignore'
      });
    } catch (err) {
      this.logger.info(`${name} at path ${pkgPath} failed to pass integrity check`);
      return false;
    }

    return true;
  }

  async _isPackagePresent({
    name,
    version
  }) {
    const pkgPath = this._genPathForPackage({
      version,
      name
    });

    try {
      return await _fsExtra.default.pathExists(_path.default.join(pkgPath, 'node_modules', '.yarn-integrity'));
    } catch (err) {
      return false;
    }
  }

  _genPathForPackage({
    name,
    version
  }) {
    return _path.default.join(this.dir, `${name}-${version}`);
  }

  _getDownloadsDirPath() {
    const fallback = _path.default.join(_os.default.homedir(), '.local', 'share');

    let localDataDir = '';

    switch (process.platform) {
      case 'darwin':
        localDataDir = _path.default.join(_os.default.homedir(), 'Library');
        break;

      case 'win32':
        localDataDir = process.env.APPDATA || fallback;
        break;

      default:
        localDataDir = process.env.XDG_DATA_HOME || fallback;
        break;
    }

    return _path.default.join(localDataDir, 'package-downloader');
  }

}

exports.default = PackageDownloader;