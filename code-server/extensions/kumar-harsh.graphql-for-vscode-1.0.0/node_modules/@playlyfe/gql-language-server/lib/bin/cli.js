#!/usr/bin/env node
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _yargs = _interopRequireDefault(require("yargs"));

var _logging = _interopRequireWildcard(require("../utils/logging"));

var _createConnection = _interopRequireWildcard(require("../createConnection"));

var _createServer = _interopRequireDefault(require("../createServer"));

var _path = _interopRequireDefault(require("path"));

const cli = _yargs.default.usage('gql-language-server Command-Line Interface.\n Usage: $0 [args]').help('h').alias('h', 'help').option('node-ipc', {
  describe: 'Use node-ipc to communicate with the server. Useful for calling from a node.js client.\n',
  type: 'string'
}).option('stdio', {
  describe: 'Use stdio to communicate with the server\n',
  type: 'string'
}).option('socket', {
  describe: 'Use a socket (with a port number like --socket=5051) to communicate with the server.\n',
  type: 'number'
}).option('gql-path', {
  describe: 'An absolute path to a gql. [default: process.cwd()]\n',
  type: 'string',
  coerce: value => {
    if (!_path.default.isAbsolute(value)) {
      throw new Error(`'gql-path' value '${value}' is not an absolute path.`);
    } // console.log(args);


    return value;
  }
}).option('config-dir', {
  describe: 'An absolute path to config dir. [default: process.cwd()] ' + 'Walks up the directory tree from the provided config directory, until a .gqlconfig file is found or the root directory is reached.\n',
  type: 'string',
  coerce: value => {
    if (!_path.default.isAbsolute(value)) {
      throw new Error(`'config-dir' value '${value}' is not an absolute path.`);
    }

    return value;
  }
}).option('auto-download-gql', {
  describe: 'Automatically download gql package if not found.\n',
  type: 'boolean',
  default: true
}).option('watchman', {
  describe: 'use watchman to watch files (if available).\n',
  type: 'boolean',
  default: true
}).option('loglevel', {
  describe: 'log level.\n',
  choices: Object.values(_logging.LOG_LEVEL),
  default: _logging.LOG_LEVEL.info
}).check(argv => {
  if (Object.values(_createConnection.CONNECTION_METHOD).filter(m => argv[m] != null).length !== 1) {
    throw new Error('gql-language-server requires exactly one valid connection option (node-ipc, stdio, or socket).');
  }

  return true;
});

const connection = (0, _createConnection.default)(getConnectionOptions(cli.argv)); // init logging

(0, _logging.default)(connection, cli.argv.loglevel); // create server

const server = (0, _createServer.default)(connection, getServerOptions(cli.argv)); // start server

server.listen();

function getConnectionOptions(argv) {
  const method = Object.values(_createConnection.CONNECTION_METHOD).find(m => argv[m] != null);

  switch (method) {
    case _createConnection.CONNECTION_METHOD.socket:
      return {
        method: 'socket',
        port: argv.socket
      };

    case _createConnection.CONNECTION_METHOD.stdio:
      return {
        method: 'stdio'
      };

    case _createConnection.CONNECTION_METHOD.nodeIpc:
      return {
        method: 'node-ipc'
      };

    default:
      return invariant(false, 'Invalid connection method');
  }
}

function getServerOptions(argv) {
  const autoDownloadGQL = argv['auto-download-gql']; // eslint-disable-next-line prefer-destructuring, dot-notation

  const watchman = argv['watchman'];
  const configDir = argv['config-dir'];
  const gqlPath = argv['gql-path']; // eslint-disable-next-line prefer-destructuring, dot-notation

  const loglevel = argv['loglevel'];
  return {
    autoDownloadGQL,
    watchman,
    configDir,
    gqlPath,
    loglevel
  };
}

function invariant(condition, ...msgs) {
  if (!condition) {
    /* eslint-disable no-console */
    console.error('ERROR:', ...msgs);
    console.error();
    /* eslint-enable */

    cli.showHelp();
    process.exit(1);
  }
}